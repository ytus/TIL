# Javascript

## `Array.reduce` doesn't need the initial value

_"If `initialValue` is provided in the call to reduce, 
then `accumulator` will be equal to `initialValue` and `currentValue` will be equal to the first value in the array. 
If no `initialValue` was provided, then accumulator will be equal to the first value in the array 
and `currentValue` will be equal to the second."_

~ http://devdocs.io/javascript/global_objects/array/reduce

## Object destructuring and default values

It's possible to use destructuring to retrieve a value from a hierarchy of objects even if some part of it is missing: 

~~~ js
const present = {
  first: {
    second: {
      third: {
        value: 'something'
      }
    }
  }
};

const missing = {
  // no `first`
};

const {first: {second: {third: {value: v1}}}={}} = present;
console.log('v1=', v1); // -> "v1=" "something"

const {first: {second: {third: {value: v2}={}}={}}={}} = missing;
console.log('v2=', v2); // -> "v2=" undefined (and no errors!)
~~~

## Promise vs. Task (or Future)

_"Promises are inherently stateful & impure, 
but you can hoist the callback pattern into a type similar to a Task 
or Future (variously named in different languages) 
just by storing the binary function that hooks callbacks 
up to some async effect. (...) But this achieves two things that Promises don't: 
it's lazy instead of eager (and hence, pure), 
and it has a synchronously exposed return value."_

~ http://degoes.net/articles/destroy-all-ifs#comment-3137616342

~ https://jsbin.com/guwuqac/edit?js,console

(& https://hackernoon.com/from-callback-to-future-functor-monad-6c86d9c16cb5 )

~~~ js
const Task = (fork) => ({
  fork: fork,
  map: (fn) => Task(
    (reject, resolve) => fork(reject, x => resolve(fn(x)))
  )
})
  
const delayedFive = Task((reject,resolve) => setTimeout(resolve,400,5))
const logError = (e) => console.log('error=', e);
const logOutput = (out) => console.log('out=' + out)

delayedFive
  .map((i) => i * 2)
  .map((i) => i + 3)
  .fork(logError, logOutput); // -> "out=13"
~~~

## parameters with default values doesn’t count on the length property of a function

_"Using default assignments wherever it makes sense can help you write more self-documenting code._

_(...)_

_There’s a caveat here: parameters with default values doesn’t count on the length property of a function. This may be useful to know if you’re doing some kind of meta-programming with the length property"_

~ https://medium.com/@sminutoli/theres-a-caveat-here-parameters-with-default-values-doesn-t-count-on-the-length-property-of-a-e7433f8adcce#.fkqll7g1x

~~~ js
> var createKey = function (a, b, c) { return `${a}:${b}:${c}`; }
< undefined
> createKey.length
< 3
> var createKey2 = function (a, b='_', c='_') { return `${a}:${b}:${c}`; } // Two default values here.
< undefined
> createKey2.length
< 1
~~~ 

## Debugging a functional code
Try `R.tap((x) => console.log('x=', x))` from [ramda](http://ramdajs.com/docs/#tap).

_"Runs the given function with the supplied object, then returns the object."_

# React

## `onClick`, `event.target` vs. `event.currentTarget` and event bubbling vs capturing

Events in HTML can be caught bubbling (going inside out) or captured (going outside in). If you want to do `capture` in React, use `onClickCapture` instead of `onClick`. The `event.target` contains the element where the event started bubbling up. The `event.currentTarget` is the element where the event was first captured going in. They are both DOM nodes (`DOMEventTarget` type in React/flowtype). 

You can get the value of an attribute from DOM node like this: 

    const key = event.currentTarget.attributes.getNamedItem('data-key').value;

~ http://javascript.info/tutorial/bubbling-and-capturing

~ https://facebook.github.io/react/docs/events.html#mouse-events

~ http://stackoverflow.com/questions/20377837/how-to-access-custom-attributes-from-event-object-in-react#comment66849996_31706457

# npm

### Scripts in ./node_modules/.bin
Those scripts can be run directly without `npm`, for example: 

    $> npm install source-map-explorer
    $> ./node_modules/.bin/source-map-explorer dist/bundle.js dist/bundle.js.map 

And this will not (and should not!) work:

    $> npm run source-map-explorer 
    $> npm ERR! missing script: source-map-explorer

~ https://github.com/npm/npm/issues/10413#issuecomment-230542256

# CSS, `box-shadow`

If you set the shadow but can't see it (on one side of the element), give that element some margin so there is actualy enough space around it to show the shadow.


# Functional programming

## `Maybe.map()` vs. `Maybe.chain()`

The function `fun` in `Maybe.map(fun)` shouldn't return `null` or `undefined`. If that's the case, then use `Maybe.chain(fun)` and change the `fun` to return (another) `Maybe`.
